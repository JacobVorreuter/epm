#!/usr/bin/env escript
%% -*- erlang -*-

-include_lib("xmerl/include/xmerl.hrl").

%% -----------------------------------------------------------------------------
%% main function
%% -----------------------------------------------------------------------------
main(Args) ->
	case (catch main1(Args)) of
		{'EXIT', ErrorMsg} when is_list(ErrorMsg) ->
			io:format("- ~s~n", [ErrorMsg]);
		{'EXIT', Other} ->
			io:format("~p~n", [Other]);
		_ ->
			ok
	end,
	dets:close(epm_index).
	
main1(Args) ->	
	inets:start(),
	
	case dets:open_file(epm_index, [{type, set}]) of
	    {ok, _} -> ok;
	    {error, Reason1} ->
	        exit(lists:flatten(io_lib:format("failed to open epm index file: ~p", [Reason1])))
	end,
	
	%% consult global .epm config file in home directory
	Home = 
		case init:get_argument(home) of
			{ok, [[H]]} -> [H];
			_ -> []
		end,
    case file:path_consult(["."] ++ Home ++ [code:root_dir()], ".epm") of
		{ok, [GlobalConfig], _} ->
			execute(GlobalConfig, Args);
		{error, enoent} ->
			execute([], Args);
		{error, Reason} ->
			io:format("- failed to read epm global config: ~p~n", [Reason])
	end.
	
%% -----------------------------------------------------------------------------
%% execute function
%% -----------------------------------------------------------------------------
execute(GlobalConfig, ["install" | Args]) ->
    {{{User, ProjectName}, CommandLineTags}, Flags} = collect_args(install, Args),
	put(verbose, lists:member(verbose, Flags)),
	Vsn = read_vsn_from_args(CommandLineTags),
	Apps = gather_remote_deps(User, ProjectName, Vsn),
	{Installed, NotInstalled} = filter_installed_deps(Apps),
	case NotInstalled of
	    [] ->
	        io:format("+ nothing to do: ~s and dependencies already installed~n", [ProjectName]);
	    _ ->
	        case Installed of
	            [] -> ok;
	            _ ->
	                io:format("===============================~n"),
                    io:format("Packages already installed:~n"),
                    io:format("===============================~n"),
                    [io:format("    + ~s-~s-~s (~s)~n", [U,N,V,AppVsn]) || {{U,N,V},AppVsn} <- Installed]
            end,
	        io:format("===============================~n"),
	        io:format("Install the following packages?~n"),
	        io:format("===============================~n"),
            [io:format("    + ~s-~s-~s~n", [U,N,V]) || {U,N,V} <- NotInstalled],
            io:format("[y/n] "),
            case io:get_chars("", 1) of
                "y" -> 
                    [install_package(GlobalConfig, U, N, V, CommandLineTags) || {U,N,V} <- NotInstalled];
                _ -> ok
            end
	end;

execute(GlobalConfig, ["remove" | Args]) ->
	{{{User, ProjectName}, CommandLineTags}, Flags} = collect_args(remove, Args),
	put(verbose, lists:member(verbose, Flags)),
	Vsn = read_vsn_from_args(CommandLineTags),
	Apps = gather_local_deps(User, ProjectName, Vsn),
	remove_package(GlobalConfig, User, ProjectName);

execute(_GlobalConfig, ["info" | Args]) ->
	{Projects, Flags} = collect_args(info, Args),
	put(verbose, lists:member(verbose, Flags)),
    [case code:lib_dir(ProjectName) of
        {error, _} -> io:format("+ ~s: not installed~n", [ProjectName]);
        Path -> io:format("+ ~s installed (~s)~n", [ProjectName, Path])
	 end || {{_User, ProjectName}, _CommandLineTags} <- Projects];
	
execute(_, _) ->
    io:format("epm v0.0.1, 2010 Nick Gerakines, Jacob Vorreuter~n"),
    io:format("Usage: epm command arguments~n"),
    io:format("    install [<user>/]<project> [--tag <tag>] [--branch <branch>] [--sha <sha>] [--force] [--verbose]~n"),
    io:format("    remove <project> [--verbose]~n"),
    io:format("    info <project> [--verbose]~n"),
    ok.

%% -----------------------------------------------------------------------------
%% parse input args
%% -----------------------------------------------------------------------------
collect_args(Target, Args) -> 
    collect_args(Target, Args, undefined, []).
collect_args(_, [], Package, Flags) -> 
    {Package, lists:reverse(Flags)};
collect_args(Target, [Arg | Rest], Package, Flags) ->
	case parse_tag(Target, Arg) of
		undefined -> %% if not a tag then must be a project name
			{ProjectName, User} = split_package(Arg), %% split into user and project
			collect_args(Target, Rest, {{User, ProjectName}, []}, Flags);
		{Tag, true} -> %% tag with trailing value
			[Value | Rest1] = Rest, %% pop trailing value from front of remaining args
			{PackageCreds, Props} = Package, %% this tag applies to the last project on the stack
			collect_args(Target, Rest1, {PackageCreds, Props ++ [{Tag, Value}]}, Flags);
		{Tag, false} ->	 %% tag with no trailing value
			{PackageCreds, Props} = Package, %% this tag applies to the last project on the stack
			collect_args(Target, Rest, {PackageCreds, Props ++ [Tag]}, Flags);
		Other ->
			collect_args(Target, Rest, Package, [Other|Flags])
	end.

%% @spec parse_tag(Target, Arg) -> {Tag, HasValue} | undefined
%%		 Target = atom()
%%		 Arg = string()
%%		 Tag = atom()
%%		 HasValue = bool()
parse_tag(install, "--tag") -> {tag, true};
parse_tag(install, "--branch") -> {branch, true};
parse_tag(install, "--sha") -> {sha, true};
parse_tag(install, "--force") -> {force, false};
parse_tag(_, "--verbose") -> verbose;
parse_tag(_, _) -> undefined.

split_package(Raw) -> split_package(Raw, []).
split_package([], Package) -> {Package, none};
split_package([47 | Package], User) -> {Package, User};
split_package([A | Tail], User) -> split_package(Tail, User ++ [A]).

%% -----------------------------------------------------------------------------
%% package info
%% -----------------------------------------------------------------------------
gather_local_deps(User, ProjectName, Vsn) ->
    case dets:lookup(epm_index, {User, ProjectName, Vsn}) of
        [{_, _, Dependencies}] -> Dependencies;
        _ -> undefined
    end.

filter_installed_deps(Apps) ->
    filter_installed_deps(Apps, [], []).
    
filter_installed_deps([], Installed, NotInstalled) ->
    {lists:reverse(Installed), NotInstalled};
    
filter_installed_deps([App|Tail], Installed, NotInstalled) ->
    case installed_app_vsn(App) of
        undefined -> filter_installed_deps(Tail, Installed, [App|NotInstalled]);
        AppVsn -> filter_installed_deps(Tail, [{App, AppVsn}|Installed], NotInstalled)
    end.
    
installed_app_vsn(App) ->
    case dets:lookup(epm_index, App) of
        [{{_,Name,_}, InstallDir}] -> 
            case file:consult(InstallDir ++ "/ebin/" ++ Name ++ ".app") of
                {ok, [{application,_,Props}]} ->
                    proplists:get_value(vsn, Props);
                {error, _} ->
                    undefined
            end;
        _ -> undefined
    end.

%% -----------------------------------------------------------------------------
%% INSTALL
%% -----------------------------------------------------------------------------
install_package(GlobalConfig, User, ProjectName, Vsn, CommandLineTags) ->
	io:format("+ install package ~s~n", [ProjectName]),
	
	%% switch to build home dir
	set_cwd_build_home(GlobalConfig),
	
	%% download correct version of package
	LocalProjectDir = download_package(User, ProjectName, Vsn),
	
	%% switch to project dir
	set_cwd_build_home(GlobalConfig),
	set_cwd(LocalProjectDir),
	
	%% build/install project
	InstallDir = build_project(GlobalConfig, ProjectName, CommandLineTags),
	
	%% switch to build home dir and delete cloned project
	set_cwd_build_home(GlobalConfig),
	del_dir(LocalProjectDir),
	
	dets:insert(epm_index, {{User, ProjectName, Vsn}, InstallDir}),
	
	ok.

remove_package(GlobalConfig, User, ProjectName) ->
    Match = 
        case User of
            none -> {{'$1',ProjectName,'$2'},'$3'};
            _ -> {{User,ProjectName,'$1'},'$2'}
        end,
    case dets:match(epm_index, Match) of
        [[GitVsn,InstallDir]] ->
            io:format("+ removing package ~s (~s)~n", [ProjectName, InstallDir]),
            RemoveCmd = "rm -rf " ++ InstallDir,
            print_cmd_output("~s~n", [RemoveCmd]),
            do_cmd(RemoveCmd, fail),
            dets:delete(epm_index, {User,ProjectName,GitVsn});
        [[GitUser,GitVsn,InstallDir]] ->
            io:format("+ removing package ~s (~s)~n", [ProjectName, InstallDir]),
            RemoveCmd = "rm -rf " ++ InstallDir,
            print_cmd_output("~s~n", [RemoveCmd]),
            do_cmd(RemoveCmd, fail),
            dets:delete(epm_index, {GitUser,ProjectName,GitVsn});
        _ ->
            io:format("- ~s is not installed~n", [ProjectName])
    end.
    
read_vsn_from_args([{tag, Tag}|_]) -> Tag;
read_vsn_from_args([{branch, Branch}|_]) -> Branch;
read_vsn_from_args([{sha, Sha}|_]) -> Sha;
read_vsn_from_args([_|Tail]) -> read_vsn_from_args(Tail);
read_vsn_from_args([]) -> "master".

search_sources_for_project(none, ProjectName) ->	
	Repos = 
		case repos_search(ProjectName) of
			#xmlElement{name=repositories, content=Repos0} -> Repos0;
			_ -> []
		end,
	Filtered = lists:filter(
		fun (#xmlElement{name=repository}=Repo) ->
				case {xmerl_xpath:string("/repository/name/text()", Repo),
					  xmerl_xpath:string("/repository/language/text()", Repo),
					  xmerl_xpath:string("/repository/type/text()", Repo)} of
					{[Name], [Lang], [Type]} ->
						Name#xmlText.value == ProjectName andalso
						Lang#xmlText.value == "Erlang" andalso
						Type#xmlText.value == "repo";
					_ ->
						false
				end;
			(_) -> false
		end, Repos),		
	if
		Filtered == [] ->
			exit(lists:flatten(io_lib:format("failed to locate remote repo for ~s", [ProjectName])));
		true -> ok
	end,
	Repo = 
		case lists:filter(
			fun(R) ->
				xmerl_xpath:string("/repository/username/text()", R) == [#xmlText{value="epm"}]
			end, Filtered) of
			[] -> hd(Filtered);
			[R1] -> R1				
		end,
	[Username] = xmerl_xpath:string("/repository/username/text()", Repo),
	[RepoName] = xmerl_xpath:string("/repository/name/text()", Repo),
	{Username#xmlText.value, RepoName#xmlText.value};
	
search_sources_for_project(User, ProjectName) ->
	case repos_info(User, ProjectName) of
		#xmlElement{name=repository}=Repo ->
			[Username] = xmerl_xpath:string("/repository/owner/text()", Repo),
			[RepoName] = xmerl_xpath:string("/repository/name/text()", Repo),
			{Username#xmlText.value, RepoName#xmlText.value};
		_ -> 
			exit(lists:flatten(io_lib:format("failed to locate remote repo for ~s", [ProjectName])))
	end.
	
set_cwd_build_home(GlobalConfig) ->	
	set_cwd(proplists:get_value(build_path, GlobalConfig, ".")).
	
set_cwd(Dir) ->
	case file:set_cwd(Dir) of
		ok -> 
			ok;
		{error, _} ->
			exit(lists:flatten(io_lib:format("failed to change working directory: ~s", [Dir])))
	end.
	
% install_dependencies(GlobalConfig, ProjectName) ->
%   Config = read_project_epm_config(ProjectName),
%   [begin
%       {ProjectName1, User} = split_package(Project),
%       case package_info(ProjectName1) of
%           {error, not_found} ->
%               install_package(GlobalConfig, User, ProjectName1, CommandLineTags);
%           {error, Reason} ->
%               io:format("- there was a problem with the installed version of ~s: ~p~n", [ProjectName1, Reason]),
%               install_package(GlobalConfig, User, ProjectName1, CommandLineTags);
%           {ok, Version} ->
%               io:format("+ skipping dependency ~s: already installed (~p)~n", [ProjectName1, Version])
%       end
%    end || {Project, CommandLineTags} <- proplists:get_value(deps, Config, [])].
	
read_project_epm_config(ProjectName) ->
	case file:consult(ProjectName ++ ".epm") of
		{ok, [Config]} ->
			Config;
		{error, Reason} ->
			io:format("- failed to read ~s.epm config: ~p - using default values~n", [ProjectName, Reason]),
			[]
	end.
	
build_project(GlobalConfig, ProjectName, _CommandLineTags) ->
	Config = 
	    case file:consult(ProjectName ++ ".epm") of
    		{ok, [Config0]} -> Config0;
    		_ -> []
    	end,
	prebuild(ProjectName, Config),
	build(ProjectName, Config),
	%test(Config), %% TODO: add back in test step
	install(ProjectName, Config, proplists:get_value(install_path, GlobalConfig)).

prebuild(ProjectName, Config) ->
    case proplists:get_value(prebuild_command, Config) of
		undefined -> ok;
		PrebuildCmd -> 
			io:format("+ running ~s prebuild command~n", [ProjectName]),
			print_cmd_output("~s~n", [PrebuildCmd]),
			do_cmd(PrebuildCmd, fail)
	end.
	
build(ProjectName, Config) ->
    BuildCmd = proplists:get_value(build_command, Config, "make"),
	io:format("+ running ~s build command~n", [ProjectName]),
	print_cmd_output("~s~n", [BuildCmd]),
	do_cmd(BuildCmd, fail).

install(ProjectName, Config, undefined) ->
	install(ProjectName, Config, code:lib_dir());

install(ProjectName, Config, LibDir) ->
	case file:consult("ebin/" ++ ProjectName ++ ".app") of
		{ok,[{application,_,Props}]} ->
			Vsn = proplists:get_value(vsn, Props, "0.0"),
			Dir = LibDir ++ "/" ++ ProjectName ++ "-" ++ Vsn,
			InstallCmd = "mkdir -p " ++ Dir ++ "; cp -R ./* " ++ Dir,
			io:format("+ running ~s install command~n", [ProjectName]),
			print_cmd_output("~s~n", [InstallCmd]),
			do_cmd(InstallCmd, fail),
			code:add_pathz(Dir),
			Dir;
		_ ->
			exit(lists:flatten(io_lib:format("failed to read ebin/~s.app", [ProjectName])))
	end.
    
del_dir(Dir) ->
	case file:list_dir(Dir) of
		{ok, Files} ->
			[begin
				case file:delete(Dir ++ "/" ++ Filename) of
					ok -> ok;
					{error, eperm} ->
						case file:del_dir(Dir ++ "/" ++ Filename) of
							ok -> ok;
							{error, eexist} ->
								del_dir(Dir ++ "/" ++ Filename)
						end
				end
			end || Filename <- Files],
			file:del_dir(Dir);
		_ ->
			ok
	end.
	
rn_dir(OldName, NewName) ->
    case file:rename(OldName, NewName) of
        ok -> ok;
        {error, Reason} ->
            exit(lists:flatten(io_lib:format("failed to rename ~s to ~s: ~p", [OldName, NewName, Reason])))
    end.
	
do_cmd(Cmd, fail) ->
	case do_cmd(Cmd) of
		{0, ""} ->
			ok;
		{0, Output} ->
			print_cmd_output("~s~n", [Output]);
		{_, Output} ->
			exit(Output)
	end.
	
do_cmd(Cmd) ->
    Results = string:tokens(os:cmd(Cmd ++ "; echo $?"), "\n"),
    [ExitCode|Other] = lists:reverse(Results),
    {list_to_integer(ExitCode), string:join(lists:reverse(Other), "\n")}.
    
print_cmd_output(Format, Args) ->
	case get(verbose) of
		undefined -> print_cmd_output(Format, Args, false);
		Verbose -> print_cmd_output(Format, Args, Verbose)
	end.
	
print_cmd_output(_, _, false) -> ok; %% do not print verbose output
print_cmd_output(Format, Args, true) ->
	Str = lists:flatten(io_lib:format("    " ++ Format, Args)),
	Output = re:replace(Str, "\n", "\n    ", [global, {return, list}]),
	io:format(string:substr(Output, 1, length(Output)-4), []).

%% -----------------------------------------------------------------------------
%% Compile Dependencies
%% -----------------------------------------------------------------------------
gather_remote_deps(User, ProjectName, Vsn) ->
    G = digraph:new(),
    gather_remote_deps(User, ProjectName, Vsn, G, undefined),
    Deps = digraph_utils:topsort(G),
    digraph:delete(G),
    Deps.
    
gather_remote_deps(User, ProjectName, Vsn, G, Parent) ->
    {GitUser, GitProjectName} = search_sources_for_project(User, ProjectName),
    
    case digraph:vertex(G, {GitUser, GitProjectName, Vsn}) of
        false -> digraph:add_vertex(G, {GitUser, GitProjectName, Vsn});
        _ -> ok
    end,
    
    case Parent of
        undefined -> ok;
        {_, ParentProjectName, _} ->
            case digraph:add_edge(G, Parent, {GitUser, GitProjectName, Vsn}) of
                {error, {bad_edge, _}} -> exit(lists:flatten(io_lib:format("circular dependency detected: ~s <--> ~s", [ParentProjectName, GitProjectName])));
                {error, Reason} -> exit(lists:flatten(io_lib:format("failed to traverse dependency tree: ~p", [Reason])));
                _ -> ok
            end
    end,
    
    [begin
        {DepName, DepUser} = split_package(Dep),
        DepVsn = read_vsn_from_args(Args),
        gather_remote_deps(DepUser, DepName, DepVsn, G, {GitUser, GitProjectName, Vsn})
     end || {Dep, Args} <- get_package_deps(GitUser, GitProjectName, Vsn)],
     
    ok.

%% -----------------------------------------------------------------------------
%% GitHub HTTP Requests
%% -----------------------------------------------------------------------------
get_package_deps(User, ProjectName, Vsn) ->
    Url = lists:flatten(io_lib:format("http://github.com/~s/~s/raw/~s/~s.epm", [User, ProjectName, Vsn, ProjectName])),
    case http:request(get, {Url, [{"User-Agent", "EPM"}, {"Host", "github.com"}]}, [{timeout, 6000}], []) of
        {ok, {{_,200,_}, _, Body}} -> 
            proplists:get_value(deps, eval(Body), []);
        _ -> []
    end.
    
repos_search(ProjectName) ->
	request_git_url("http://github.com/api/v2/xml/repos/search/" ++ ProjectName).
	
repos_info(User, ProjectName) ->
	request_git_url("http://github.com/api/v2/xml/repos/show/" ++ User ++ "/" ++ ProjectName).
	
request_git_url(Url) ->
    {ok, {{_, _RespCode, _}, _Headers, Body}} = 
		http:request(get, {Url, [{"User-Agent", "EPM"}, {"Host", "github.com"}]}, [{timeout, 6000}], []),
	{XmlElement, _} = xmerl_scan:string(Body),
	XmlElement.

download_package(User, ProjectName, Vsn) ->
    {GitUser, GitProjectName} = search_sources_for_project(User, ProjectName),
    LocalProjectDir = GitUser ++ "-" ++ GitProjectName,
    Url = download_url(GitUser, GitProjectName, Vsn),
    io:format("+ downloading ~s~n", [Url]),
    case http:request(get, {Url, [{"User-Agent", "EPM"}, {"Host", "github.com"}]}, [{timeout, 6000}], [{body_format, binary}]) of
        {ok,{{_,200,_},_,Bin}} ->
            case erl_tar:table({binary, Bin}, [compressed]) of
                {ok,[_,TarName|_]} ->
                    del_dir(TarName),
                    del_dir(LocalProjectDir),
                    case erl_tar:extract({binary, Bin}, [compressed]) of
                        ok -> 
                            rn_dir(TarName, LocalProjectDir),
                            LocalProjectDir;
                        {error, Reason} ->
                            exit(lists:flatten(io_lib:format("failed to extract ~s tarball: ~p", [ProjectName, Reason])))
                    end;
                {error, Reason1} ->
                    exit(lists:flatten(io_lib:format("failed to extract ~s tarball: ~p", [ProjectName, Reason1])))
            end;
        {ok, {{_,404,_},_,_}} ->
            exit(lists:flatten(io_lib:format("remote project does not exist: ~s/~s/~s", [GitUser, GitProjectName, Vsn])));
        Error ->
            io:format("~p~n", [Error]),
            exit(lists:flatten(io_lib:format("failed to download ~s tarball", [ProjectName])))
    end.
            
download_url(GitUser, GitProjectName, Vsn) ->
    lists:flatten(io_lib:format("http://github.com/~s/~s/tarball/~s", [GitUser, GitProjectName, Vsn])).
    
%% -----------------------------------------------------------------------------
%% util functions
%% -----------------------------------------------------------------------------
eval(Str) ->
    case erl_scan:string(Str) of
        {ok,Tokens,_} ->
            case erl_parse:parse_exprs(Tokens) of
                {ok,Forms} ->
                    case erl_eval:exprs(Forms,[]) of
                        {value, Terms, _} -> Terms;
                        _ -> error
                    end;
                _ -> error
            end;
        _ -> error
    end.
