#!/usr/bin/env escript
%% -*- erlang -*-

-include_lib("xmerl/include/xmerl.hrl").

-record(repository, {name, owner, description, homepage, followers}).

%% -----------------------------------------------------------------------------
%% main function
%% -----------------------------------------------------------------------------
main(Args) ->
	io:format("epm v0.1.0, 2010~n~n"),
	case (catch main1(Args)) of
		{'EXIT', ErrorMsg} when is_list(ErrorMsg) ->
			io:format("- ~s~n", [ErrorMsg]);
		{'EXIT', Other} ->
			io:format("~p~n", [Other]);
		_ ->
			ok
	end,
	dets:close(epm_index),
	io:format("~n").
	
main1(Args) ->	
	inets:start(),
	
	case dets:open_file(epm_index, [{type, set}]) of
	    {ok, _} -> ok;
	    {error, {file_error,_,eacces}} ->
            exit(lists:flatten(io_lib:format("insufficient access to epm index file.", [])));
	    {error, Reason1} ->
	        exit(lists:flatten(io_lib:format("failed to open epm index file: ~p", [Reason1])))
	end,
	
	%% consult global .epm config file in home directory
	Home = 
		case init:get_argument(home) of
			{ok, [[H]]} -> [H];
			_ -> []
		end,
    case file:path_consult(["."] ++ Home ++ [code:root_dir()], ".epm") of
		{ok, [GlobalConfig], _} ->
		    case proplists:get_value(install_dir, GlobalConfig) of
		        undefined -> ok;
		        InstallDir -> add_to_path(InstallDir)
		    end,
			execute(GlobalConfig, Args);
		{error, enoent} ->
			execute([], Args);
		{error, Reason} ->
			io:format("- failed to read epm global config: ~p~n", [Reason])
	end.
	
%% -----------------------------------------------------------------------------
%% execute function
%% -----------------------------------------------------------------------------
execute(GlobalConfig, ["install" | Args]) ->
    {Packages, Flags} = collect_args(install, Args),
	put(verbose, lists:member(verbose, Flags)),
	Apps = gather_remote_deps(Packages),
	{Installed, NotInstalled} = filter_installed_deps(Apps),
	case NotInstalled of
	    [] ->
	        io:format("+ nothing to do: packages and dependencies already installed~n");
	    _ ->
	        case Installed of
	            [] -> ok;
	            _ ->
	                io:format("===============================~n"),
                    io:format("Packages already installed:~n"),
                    io:format("===============================~n"),
                    [io:format("    + ~s-~s-~s (~s)~n", [U,N,V,proplists:get_value(vsn, Props)]) || {{U,N,V},Props} <- Installed]
            end,
	        io:format("===============================~n"),
	        io:format("Install the following packages?~n"),
	        io:format("===============================~n"),
            [io:format("    + ~s-~s-~s~n", [U,N,V]) || {{U,N,V},_} <- NotInstalled],
            io:format("~n([y]/n) "),
            case io:get_chars("", 1) of
                C when C == "y"; C == "\n" -> 
                    io:format("~n"),
                    [install_package(GlobalConfig, U, N, V, proplists:get_value(deps, Props)) || {{U,N,V},Props} <- NotInstalled];
                _ -> ok
            end
	end;

execute(GlobalConfig, ["remove" | Args]) ->
	{Packages, Flags} = collect_args(remove, Args),
	put(verbose, lists:member(verbose, Flags)),
	Installed0 = dict:to_list(installed_packages(Packages)),
	DependantPackages = dependant_installed_packages(proplists:get_keys(Installed0)),
    Installed = lists:usort(lists:append(Installed0, DependantPackages)),
	case Installed of
	    [] ->
	        io:format("+ nothing to remove: no matching packages installed~n");
	    _ ->
	        io:format("===============================~n"),
	        io:format("Remove the following packages?~n"),
	        io:format("===============================~n"),
            [io:format("    + ~s-~s-~s~n", [U,N,V]) || {{U,N,V},_} <- Installed],
            io:format("~n([y]/n) "),
            case io:get_chars("", 1) of
                C when C == "y"; C == "\n" -> 
                    io:format("~n"),
                    [remove_package(GlobalConfig, U, N, V, InstallDir) || {{U,N,V},{InstallDir,_Deps}} <- Installed];
                _ -> ok
            end
    end;
    
execute(GlobalConfig, ["update" | Args]) ->
    {Packages, Flags} = collect_args(update, Args),
    put(verbose, lists:member(verbose, Flags)),
    Installed = dict:to_list(installed_packages(Packages)),
    case Installed of
		[] ->
		    io:format("- nothing to update~n");
		_ ->
			io:format("===============================~n"),
			io:format("Update the following packages?~n"),
			io:format("===============================~n"),
			[io:format("    + ~s-~s-~s~n", [U,N,V]) || {{U,N,V},_} <- Installed],
            io:format("~n([y]/n) "),
            case io:get_chars("", 1) of
                C when C == "y"; C == "\n" -> 
                    io:format("~n"),
                    [update_package(GlobalConfig, U, N, V, InstallDir, Deps) || {{U,N,V},{InstallDir,Deps}} <- Installed];
                _ -> ok
            end
	end;
	
execute(_GlobalConfig, ["search" | Args]) ->
    {Packages, Flags} = collect_args(search, Args),
    put(verbose, lists:member(verbose, Flags)),
    write_not_installed_package_info([{U,N,read_vsn_from_args(CommandLineArgs)} || {{U,N},CommandLineArgs} <- lists:reverse(Packages)]);
    
execute(_GlobalConfig, ["info" | Args]) ->
	{Packages, Flags} = collect_args(info, Args),
	put(verbose, lists:member(verbose, Flags)),
    {Installed, NotInstalled} = lists:foldl(
		fun({{User, ProjectName}, CommandLineTags}, {TempInstalled, TempNotInstalled}) ->
			Vsn = read_vsn_from_args(CommandLineTags, undefined),
	        case local_package_info(User, ProjectName, Vsn) of
				undefined ->
					{TempInstalled, [{User, ProjectName, Vsn}|TempNotInstalled]};
				{GitUser,_,GitVsn,InstallDir,Deps} ->
					{[{GitUser,ProjectName,GitVsn,InstallDir,Deps}|TempInstalled], TempNotInstalled}
			end	
		end, {[], []}, Packages),
	case Installed of
		[] -> ok;
		_ ->
			io:format("===============================~n"),
			io:format("INSTALLED~n"),
			io:format("===============================~n"),
			
			lists:foldl(
				fun({User, ProjectName, Vsn, InstallDir, Deps}, Count) ->
					case Count of
						0 -> ok;
						_ -> io:format("~n")
					end,
					write_installed_package_info(User, ProjectName, Vsn, InstallDir, Deps),
					Count+1
				end, 0, lists:reverse(Installed))
	end,
	
	case NotInstalled of
		[] -> ok;
		_ ->
			case Installed of
				[] -> ok;
				_ -> io:format("~n")
			end,
			write_not_installed_package_info(NotInstalled)
	end;
        
	
execute(_GlobalConfig, ["list" | Args]) ->
    {_Packages, Flags} = collect_args(list, Args),
	put(verbose, lists:member(verbose, Flags)),
    Installed = installed_packages(),
    case Installed of
		[] -> 
		    io:format("- no packages installed~n");
		_ ->
			io:format("===============================~n"),
			io:format("INSTALLED~n"),
			io:format("===============================~n"),

			lists:foldl(
				fun({User, ProjectName, Vsn, InstallDir, Deps}, Count) ->
					case Count of
						0 -> ok;
						_ -> io:format("~n")
					end,
					write_installed_package_info(User, ProjectName, Vsn, InstallDir, Deps),
					Count+1
				end, 0, lists:reverse(Installed))
	end;
	
execute(_, _) ->
    io:format("Usage: epm command arguments~n"),
    io:format("    install [[<user>/]<project> [--tag <tag>] [--branch <branch>] [--sha <sha>] [--with-deps (default)] [--without-deps],] [--verbose]~n"),
    io:format("    remove [[<user>/]<project> [--tag <tag>] [--branch <branch>] [--sha <sha>] [--with-deps] [--without-deps (default)],] [--verbose]~n"),
    io:format("    update [<project> [--tag <tag>] [--branch <branch>] [--sha <sha>] [--with-deps] [--without-deps (default)],]~n"),
    io:format("    info [[<user>/]<project>,] [--verbose]~n"),
    io:format("    list [--verbose]~n"),
    io:format("    search [<project>,]~n"),
    ok.

%% -----------------------------------------------------------------------------
%% parse input args
%% -----------------------------------------------------------------------------
collect_args(Target, Args) -> 
    collect_args(Target, Args, [], []).
collect_args(_, [], Packages, Flags) -> 
    {lists:reverse(Packages), lists:reverse(Flags)};
collect_args(Target, [Arg | Rest], Packages, Flags) ->
	case parse_tag(Target, Arg) of
		undefined -> %% if not a tag then must be a project name
			{ProjectName, User} = split_package(Arg), %% split into user and project
			collect_args(Target, Rest, [{{User, ProjectName}, []}|Packages], Flags);
		{Tag, true} -> %% tag with trailing value
			[Value | Rest1] = Rest, %% pop trailing value from front of remaining args
			[{PackageCreds, Props}|OtherPackages] = Packages, %% this tag applies to the last project on the stack
			collect_args(Target, Rest1, [{PackageCreds, Props ++ [{Tag, Value}]}|OtherPackages], Flags);
		{Tag, false} ->	 %% tag with no trailing value
			[{PackageCreds, Props}|OtherPackages] = Packages, %% this tag applies to the last project on the stack
			collect_args(Target, Rest, [{PackageCreds, Props ++ [Tag]}|OtherPackages], Flags);
		Flag ->
			collect_args(Target, Rest, Packages, [Flag|Flags])
	end.

%% @spec parse_tag(Target, Arg) -> {Tag, HasValue} | undefined
%%		 Target = atom()
%%		 Arg = string()
%%		 Tag = atom()
%%		 HasValue = bool()
parse_tag(install, "--tag") -> {tag, true};
parse_tag(install, "--branch") -> {branch, true};
parse_tag(install, "--sha") -> {sha, true};

parse_tag(info, "--tag") -> {tag, true};
parse_tag(info, "--branch") -> {branch, true};
parse_tag(info, "--sha") -> {sha, true};

parse_tag(_, "--with-deps") -> {with_deps, false};
parse_tag(_, "--without-deps") -> {without_deps, false};

parse_tag(_, "--verbose") -> verbose;

parse_tag(_, _) -> undefined.

split_package(Raw) -> split_package(Raw, []).
split_package([], Package) -> {Package, none};
split_package([47 | Package], User) -> {Package, User};
split_package([A | Tail], User) -> split_package(Tail, User ++ [A]).

%% -----------------------------------------------------------------------------
%% package info
%% -----------------------------------------------------------------------------	
installed_packages() ->
    [begin
        {User, ProjectName, Vsn, InstallDir, Deps}
     end || [{{User,ProjectName,Vsn},InstallDir,Deps}] <- dets:match(epm_index, '$1')].
        
installed_packages(Packages) ->
    installed_packages(Packages, dict:new()).
    
installed_packages([], Dict) ->
    Dict;
    
installed_packages([{{User, ProjectName}, CommandLineTags}|Tail], Dict) ->
    Vsn = read_vsn_from_args(CommandLineTags),
    FollowDeps = lists:member(with_deps, CommandLineTags),
    installed_packages([{User, ProjectName, Vsn, FollowDeps}|Tail], Dict);
    
installed_packages([{User, ProjectName, Vsn, FollowDeps}|Tail], Dict) ->
    Dict1 = 
        case local_package_info(User, ProjectName, Vsn) of
            undefined ->
                Dict;
            {User1, _, Vsn1, InstallDir1, Deps1} ->
                TempDict1 = 
                    case FollowDeps of
                        true ->
                            lists:foldl(
                                fun({DepUser, DepName, DepVsn}, TempDict) ->
                                    installed_packages([{DepUser, DepName, DepVsn, FollowDeps}], TempDict)
                                end, Dict, Deps1);
                        false ->
                            Dict
                    end,
                dict:store({User1, ProjectName, Vsn1}, {InstallDir1, Deps1}, TempDict1)
        end,
    installed_packages(Tail, Dict1).
    
dependant_installed_packages(Packages) ->
    dependant_installed_packages(Packages, []).
    
dependant_installed_packages([], Acc) -> Acc;
dependant_installed_packages([Package|Tail], Acc) ->
    Acc1 = dependant_installed_packages(Package, Acc, dets:match(epm_index, '$1')),
    dependant_installed_packages(Tail, Acc1).

dependant_installed_packages(_Package, Acc, []) -> Acc;
dependant_installed_packages({User, Name, Vsn}, Acc, [[{Installed,InstallDir,Deps}]|Tail]) ->
    Acc1 = case lists:filter(
            fun({U,N,V}) ->
                (U==User orelse U==none) andalso
                (N==Name) andalso
                (V==Vsn)
            end, Deps) of
        [] -> Acc;
        [_] -> [{Installed,{InstallDir,Deps}}|Acc]
    end,
    dependant_installed_packages({User, Name, Vsn}, Acc1, Tail).
        
installed_app_vsn(App) ->
    case dets:lookup(epm_index, App) of
        [{{_,Name,_}, InstallDir, _Deps}] -> 
            case file:consult(InstallDir ++ "/ebin/" ++ Name ++ ".app") of
                {ok, [{application,_,Props}]} ->
                    proplists:get_value(vsn, Props);
                {error, _} ->
                    undefined
            end;
        _ -> undefined
    end.
    
local_package_info(none, ProjectName, undefined) ->
    case dets:match(epm_index, {{'$1',ProjectName,'$2'},'$3','$4'}) of
        [] -> undefined;
        [[User,Vsn,InstallDir,Deps]] ->
            {User,ProjectName,Vsn,InstallDir,Deps}
    end;    
local_package_info(none, ProjectName, Vsn) ->
    case dets:match(epm_index, {{'$1',ProjectName,Vsn},'$2','$3'}) of
        [] -> undefined;
        [[User,InstallDir,Deps]] ->
            {User,ProjectName,Vsn,InstallDir,Deps}
    end;
local_package_info(User, ProjectName, undefined) ->
    case dets:match(epm_index, {{User,ProjectName,'$1'},'$2','$3'}) of
        [] -> undefined;
        [[Vsn,InstallDir,Deps]] ->
            {User,ProjectName,Vsn,InstallDir,Deps}
    end;
local_package_info(User, ProjectName, Vsn) ->
    case dets:match(epm_index, {{User,ProjectName,Vsn},'$1','$2'}) of
        [] -> undefined;
        [[InstallDir,Deps]] ->
            {User,ProjectName,Vsn,InstallDir,Deps}
    end.

%% -----------------------------------------------------------------------------
%% Print package info
%% -----------------------------------------------------------------------------	
write_installed_package_info(User, ProjectName, Vsn, InstallDir, Deps) ->
	Repo = 
	    case repos_info(User, ProjectName) of
	        #repository{}=R0 -> R0;
	        Err -> exit(lists:flatten(io_lib:format("failed to fetch remote repo info for ~s: ~p", [ProjectName, Err])))
	    end,
    [io:format("  ~s: ~s~n", [Field, if Value==undefined -> ""; true -> Value end]) || {Field, Value} <- [
		{"name", ProjectName},
		{"owner", User},
		{"vsn", Vsn},
		{"install dir", InstallDir},
		{"homepage", Repo#repository.homepage},
		{"description", Repo#repository.description}
	]],
    case Deps of
        [] -> ok;
        _ ->
            io:format("  dependencies: ~n    ~s~n", [string:join([
             case U of
				none -> lists:flatten(io_lib:format("~s/~s", [N,V]));
				_ -> lists:flatten(io_lib:format("~s/~s/~s", [U,N,V]))
             end || {U,N,V} <- Deps], "\n    ")])
    end.
    
write_not_installed_package_info(Packages) ->
    case write_not_installed_package_info(Packages, []) of
        [] -> 
            io:format("- not found~n");
        Results ->
            io:format("===============================~n"),
        	io:format("AVAILABLE~n"),
        	io:format("===============================~n"),
        	[write_not_installed_package_info(User, ProjectName, Vsn, Repos) || {{User, ProjectName, Vsn}, Repos} <- Results]
    end.

write_not_installed_package_info([], Acc) -> Acc;
write_not_installed_package_info([{User, ProjectName, Vsn}|Tail], Acc) ->
    Acc1 = 
        case User of
    		none -> 
    		    case repos_search(ProjectName) of
    		        [] -> Acc;
    		        Repos when is_list(Repos) -> [{{User, ProjectName, Vsn}, Repos}|Acc];
    		        _ -> Acc
    		    end;
    		_ -> 
    			case repos_info(User, ProjectName) of
    				#repository{}=R -> [{{User, ProjectName, Vsn}, [R]}|Acc];
    				_ -> Acc
    			end
    	end,
    write_not_installed_package_info(Tail, Acc1).
    
write_not_installed_package_info(_User, ProjectName, _Vsn, Repos) ->
	lists:foldl(
		fun(Repo, Count) ->
			Tags = repos_tags(Repo#repository.owner, ProjectName),
			Branches = repos_branches(Repo#repository.owner, ProjectName),
			case Count of
				0 -> ok;
				_ -> io:format("~n")
			end,
			[io:format("  ~s: ~s~n", [Field, if Value==undefined -> ""; true -> Value end]) || {Field, Value} <- [
				{"name", ProjectName},
				{"owner", Repo#repository.owner},
				{"followers", Repo#repository.followers},
				{"homepage", Repo#repository.homepage},
				{"description", Repo#repository.description}
			]],
			if 
			    Tags =/= [] -> 
			        io:format("  tags:~n"),
			        [io:format("    ~s~n", [K]) || {K,_V} <- Tags];
			    true -> ok
			end,
			if 
			    Branches =/= [] -> 
		            io:format("  branches:~n"),
		            [io:format("    ~s~n", [K]) || {K,_V} <- Branches];
			    true -> ok 
			end,
			Count+1
		end, 0, Repos).

retrieve_remote_repo(none, ProjectName) ->	
    case repos_search(ProjectName) of
        [] ->
            exit(lists:flatten(io_lib:format("failed to locate remote repo for ~s", [ProjectName])));
        [R0|_] ->
            R0;
        Err ->
            exit(lists:flatten(io_lib:format("failed to locate remote repo for ~s: ~p", [ProjectName, Err])))
    end;
	
retrieve_remote_repo(User, ProjectName) ->
	case repos_info(User, ProjectName) of
		#repository{}=Repo ->
			Repo;
		Err -> 
			exit(lists:flatten(io_lib:format("failed to locate remote repo for ~s: ~p", [ProjectName, Err])))
	end.
	
%% -----------------------------------------------------------------------------
%% INSTALL
%% -----------------------------------------------------------------------------
install_package(GlobalConfig, User, ProjectName, Vsn, Deps) ->
	%% switch to build home dir
	set_cwd_build_home(GlobalConfig),
	
	%% download correct version of package
	LocalProjectDir = download_package(User, ProjectName, Vsn),
	
	%% switch to project dir
	set_cwd_build_home(GlobalConfig),
	set_cwd(LocalProjectDir),
	
	%% build/install project
	InstallDir = build_project(GlobalConfig, ProjectName),
	
	%% switch to build home dir and delete cloned project
	set_cwd_build_home(GlobalConfig),
	del_dir(LocalProjectDir),
	
	dets:insert(epm_index, {{User, ProjectName, Vsn}, InstallDir, Deps}),
	
	ok.

%% -----------------------------------------------------------------------------
%% REMOVE
%% -----------------------------------------------------------------------------
remove_package(_GlobalConfig, User, ProjectName, Vsn, InstallDir) ->
    io:format("+ removing package ~s-~s-~s from ~s~n", [User, ProjectName, Vsn, InstallDir]),
    RemoveCmd = "rm -rf " ++ InstallDir,
    print_cmd_output("~s~n", [RemoveCmd]),
    do_cmd(RemoveCmd, fail),
    dets:delete(epm_index, {User,ProjectName,Vsn}).

%% -----------------------------------------------------------------------------
%% UPDATE
%% ----------------------------------------------------------------------------- 
update_package(GlobalConfig, User, ProjectName, Vsn, _InstallDir, _Deps) ->
    %% switch to build home dir
	set_cwd_build_home(GlobalConfig),
	
	%% download correct version of package
	LocalProjectDir = download_package(User, ProjectName, Vsn),
	
	%% switch to project dir
	set_cwd_build_home(GlobalConfig),
	set_cwd(LocalProjectDir),
	
	%% build/install project
	_InstallDir = build_project(GlobalConfig, ProjectName),
	
	%% switch to build home dir and delete cloned project
	set_cwd_build_home(GlobalConfig),
	del_dir(LocalProjectDir).
       
read_vsn_from_args(Args) ->
    read_vsn_from_args(Args, "master").
    
read_vsn_from_args([{tag, Tag}|_], _) -> Tag;
read_vsn_from_args([{branch, Branch}|_], _) -> Branch;
read_vsn_from_args([{sha, Sha}|_], _) -> Sha;
read_vsn_from_args([_|Tail], Default) -> read_vsn_from_args(Tail, Default);
read_vsn_from_args([], Default) -> Default.
		
build_project(GlobalConfig, ProjectName) ->
	Config = 
	    case file:consult(ProjectName ++ ".epm") of
    		{ok, [Config0]} -> Config0;
    		_ -> []
    	end,
	prebuild(ProjectName, Config),
	build(ProjectName, Config),
	test(ProjectName, Config),
	install(ProjectName, Config, proplists:get_value(install_dir, GlobalConfig)).

prebuild(ProjectName, Config) ->
    case proplists:get_value(prebuild_command, Config) of
		undefined -> ok;
		PrebuildCmd -> 
			io:format("+ running ~s prebuild command~n", [ProjectName]),
			print_cmd_output("~s~n", [PrebuildCmd]),
			do_cmd(PrebuildCmd, fail)
	end.
	
build(ProjectName, Config) ->
    BuildCmd = proplists:get_value(build_command, Config, "make"),
	io:format("+ running ~s build command~n", [ProjectName]),
	print_cmd_output("~s~n", [BuildCmd]),
	do_cmd(BuildCmd, fail).

test(ProjectName, Config) ->
    case proplists:get_value(test_command, Config) of
		undefined -> ok;
		TestCmd -> 
			io:format("+ running ~s test command~n", [ProjectName]),
			print_cmd_output("~s~n", [TestCmd]),
			do_cmd(TestCmd, fail)
	end.
	
install(ProjectName, Config, undefined) ->
	install(ProjectName, Config, code:lib_dir());

install(ProjectName, _Config, LibDir) ->
	Vsn = 
	    case file:consult("ebin/" ++ ProjectName ++ ".app") of
    		{ok,[{application,_,Props}]} ->
    			proplists:get_value(vsn, Props);
    		_ ->
    			undefined
    	end,
    Dir = 
        case Vsn of
            undefined -> LibDir ++ "/" ++ ProjectName;
            _ -> LibDir ++ "/" ++ ProjectName ++ "-" ++ Vsn
        end,
	InstallCmd = "mkdir -p " ++ Dir ++ "; cp -R ./* " ++ Dir,
	io:format("+ running ~s install command~n", [ProjectName]),
	print_cmd_output("~s~n", [InstallCmd]),
	do_cmd(InstallCmd, fail),
	Ebin = Dir ++ "/ebin",
	case code:add_pathz(Ebin) of
	    true ->
	        ok;
	    Err ->
	        exit(lists:flatten(io_lib:format("failed to add path for ~s (~s): ~p", [ProjectName, Ebin, Err])))
	end,
	Dir.

%% -----------------------------------------------------------------------------
%% Compile list of dependencies
%% -----------------------------------------------------------------------------
%% returns [{{User,Name,Vsn},[{deps, Deps}]}]
gather_remote_deps(Packages) ->
    G = digraph:new(),
    AppInfo = gather_remote_deps(Packages, G, undefined, dict:new()),
    Deps = digraph_utils:topsort(G),
    digraph:delete(G),
    [{Dep, dict:fetch(Dep, AppInfo)} || Dep <- Deps].
   
gather_remote_deps([], _, _, Dict) -> Dict;
gather_remote_deps([{{User, ProjectName}, CommandLineTags}|Tail], G, Parent, Dict) ->
    Repo = retrieve_remote_repo(User, ProjectName),
    Vsn = read_vsn_from_args(CommandLineTags),
    WithoutDeps = lists:member(without_deps, CommandLineTags),
	Key = {Repo#repository.owner, Repo#repository.name, Vsn},
    
    digraph:add_vertex(G, Key),
    
    case Parent of
        undefined -> ok;
        {_, ParentProjectName, _} ->
            digraph:add_edge(G, Parent, Key),
            case digraph_utils:is_acyclic(G) of
                true ->
                    ok;
                false ->
                    exit(lists:flatten(io_lib:format("circular dependency detected: ~s <--> ~s", [ParentProjectName, Repo#repository.name])))
            end
    end,
    
    {Deps, Dict1} = 
        case WithoutDeps of
            true ->
                {[], Dict};
            false ->
                lists:mapfoldl(
                    fun({Dep, Args}, TempDict) -> 
                        {DepName, DepUser} = split_package(Dep),
                        DepVsn = read_vsn_from_args(Args),
                        TempDict1 = gather_remote_deps([{{DepUser, DepName}, Args}], G, Key, TempDict),
                        {{DepUser, DepName, DepVsn}, TempDict1} 
                    end, Dict, get_package_deps(Repo#repository.owner, Repo#repository.name, Vsn))
        end,
    
    Dict2 = dict:store(Key, [{deps, Deps}], Dict1),
    gather_remote_deps(Tail, G, Parent, Dict2).

filter_installed_deps(Apps) ->
    filter_installed_deps(Apps, [], []).
    
filter_installed_deps([], Installed, NotInstalled) ->
    {lists:reverse(Installed), NotInstalled};
    
filter_installed_deps([{App,Info}|Tail], Installed, NotInstalled) ->
    case installed_app_vsn(App) of
        undefined -> filter_installed_deps(Tail, Installed, [{App,Info}|NotInstalled]);
        AppVsn -> filter_installed_deps(Tail, [{App,[{vsn, AppVsn}|Info]}|Installed], NotInstalled)
    end.

%% -----------------------------------------------------------------------------
%% GitHub API Interface
%% -----------------------------------------------------------------------------
get_package_deps(User, ProjectName, Vsn) ->
    Url = lists:flatten(io_lib:format("http://github.com/~s/~s/raw/~s/~s.epm", [User, ProjectName, Vsn, ProjectName])),
    case git_request_as_str(Url) of
        Body when is_list(Body) -> proplists:get_value(deps, eval(Body), []);
        _ -> []
    end.
    
repos_search(ProjectName) ->
	case git_request_as_xml("http://github.com/api/v2/xml/repos/search/" ++ ProjectName) of
		#xmlElement{name=repositories, content=Repos} ->
			Found = lists:reverse(lists:foldl(
				fun (#xmlElement{name=repository}=Repo, Acc) ->
						case {xmerl_xpath:string("/repository/name/text()", Repo),
							  xmerl_xpath:string("/repository/language/text()", Repo),
							  xmerl_xpath:string("/repository/type/text()", Repo)} of
							{[#xmlText{value=Name}], [#xmlText{value="Erlang"}], [#xmlText{value="repo"}]} ->
								[#repository{
									name = Name,
            						owner = repo_xml_field("username", Repo),
            						description = repo_xml_field("description", Repo),
            						homepage = repo_xml_field("homepage", Repo),
            						followers = repo_xml_field("followers", Repo)
								}|Acc];
							_ ->
								Acc
						end;
					(_, Acc) -> Acc
			end, [], Repos)),
			case repos_info("epm", ProjectName) of
			    #repository{}=R0 ->
			        case lists:filter(
			                fun(R1) ->
			                    R1#repository.name==R0#repository.name andalso R1#repository.owner==R0#repository.owner
			                end, Found) of
			            [] -> [R0|Found];
			            _ -> Found
			        end;
			    _ ->
			        Found
			end;
		Err -> 
		    Err
	end.
	
repos_info(User, ProjectName) ->
	case git_request_as_xml("http://github.com/api/v2/xml/repos/show/" ++ User ++ "/" ++ ProjectName) of
		#xmlElement{name=repository}=Repo ->
			case xmerl_xpath:string("/repository/name/text()", Repo) of
				[#xmlText{value=Name}] ->					
					#repository{
						name = Name,
						owner = repo_xml_field("owner", Repo),
						description = repo_xml_field("description", Repo),
						homepage = repo_xml_field("homepage", Repo),
						followers = repo_xml_field("followers", Repo)
					};
				_ ->
					undefined
			end;
		Err ->
			Err
	end.
	
repo_xml_field(FieldName, Repo) ->
    case xmerl_xpath:string("/repository/" ++ FieldName ++ "/text()", Repo) of
		[#xmlText{value=Value}] -> Value;
		_ -> undefined
	end.

repos_tags(User, ProjectName) ->
    Url = "http://github.com/api/v2/yaml/repos/show/" ++ User ++ "/" ++ ProjectName ++ "/tags",
    case git_request_as_str(Url) of
        "--- \ntags: {}\n\n" -> [];
        "--- \ntags: \n" ++ Body -> 
            [begin
                [K,V] = string:tokens(Token, ":"),
                {string:strip(K), string:strip(V)} 
             end || Token <- string:tokens(Body, "\n")];
        _ -> []
    end.
	
repos_branches(User, ProjectName) ->
    Url = "http://github.com/api/v2/yaml/repos/show/" ++ User ++ "/" ++ ProjectName ++ "/branches",
    case git_request_as_str(Url) of
        "--- \nbranches: {}\n\n" -> [];
        "--- \nbranches: \n" ++ Body -> 
            [begin
                [K,V] = string:tokens(Token, ":"),
                {string:strip(K), string:strip(V)} 
             end || Token <- string:tokens(Body, "\n")];
		_ -> []
	end.
		
git_request_as_xml(Url) ->
    case git_request_as_str(Url) of
        Body when is_list(Body) ->
            case xmerl_scan:string(Body) of
                {XmlElement, _} ->
                    XmlElement;
                _ ->
                    poorly_formatted_xml
            end;
        Err ->
            Err
    end.
    
git_request_as_str(Url) ->
    case http:request(get, {Url, [{"User-Agent", "EPM"}, {"Host", "github.com"}]}, [{timeout, 6000}], []) of
        {ok, {{_, 200, _}, _, Body}} ->
	        Body;
	    {ok, {{_, 403, _}, _, _}} ->
	        not_found;
        {ok, {{_, 404, _}, _, _}} ->
	        not_found;
	    {error, Reason} ->
	        io:format("timeout? ~p~n", [Reason]),
	        Reason
	end.

download_package(User, ProjectName, Vsn) ->
    Repo = retrieve_remote_repo(User, ProjectName),
    LocalProjectDir = Repo#repository.owner ++ "-" ++ Repo#repository.name,
    Url = lists:flatten(io_lib:format("http://github.com/~s/~s/tarball/~s", [Repo#repository.owner, Repo#repository.name, Vsn])),
    io:format("+ downloading ~s~n", [Url]),
    case http:request(get, {Url, [{"User-Agent", "EPM"}, {"Host", "github.com"}]}, [{timeout, 6000}], [{body_format, binary}]) of
        {ok,{{_,200,_},_,Bin}} ->
            case erl_tar:table({binary, Bin}, [compressed]) of
                {ok,[_,TarName|_]} ->
                    del_dir(TarName),
                    del_dir(LocalProjectDir),
                    case erl_tar:extract({binary, Bin}, [compressed]) of
                        ok -> 
                            rn_dir(TarName, LocalProjectDir),
                            LocalProjectDir;
                        {error, Reason} ->
                            exit(lists:flatten(io_lib:format("failed to extract ~s tarball: ~p", [ProjectName, Reason])))
                    end;
                {error, Reason1} ->
                    exit(lists:flatten(io_lib:format("failed to extract ~s tarball: ~p", [ProjectName, Reason1])))
            end;
        {ok, {{_,404,_},_,_}} ->
            exit(lists:flatten(io_lib:format("remote project does not exist: ~s/~s/~s", [Repo#repository.owner, Repo#repository.name, Vsn])));
        Error ->
            io:format("~p~n", [Error]),
            exit(lists:flatten(io_lib:format("failed to download ~s tarball", [ProjectName])))
    end.
    
%% -----------------------------------------------------------------------------
%% util functions
%% -----------------------------------------------------------------------------
eval(Str) ->
    case erl_scan:string(Str) of
        {ok,Tokens,_} ->
            case erl_parse:parse_exprs(Tokens) of
                {ok,Forms} ->
                    case erl_eval:exprs(Forms,[]) of
                        {value, Terms, _} -> Terms;
                        _ -> error
                    end;
                _ -> error
            end;
        _ -> error
    end.

add_to_path(InstallDir) ->
	case file:list_dir(InstallDir) of
		{ok, Files} ->
		    [begin
		        File = filename:join([InstallDir, File0]),
		        case filelib:is_dir(File) of
		            true ->
		                Ebin = filename:join([File, "ebin"]),
		                case filelib:wildcard(Ebin ++ "/*.app") of
		                    [App|_] ->
		                        case file:consult(App) of
		                            {ok, _} ->
		                                code:add_pathz(Ebin);
		                            _ ->
		                                ok
		                        end;
		                    _ ->
		                        ok
		                end;
		            false -> ok
		        end
		     end || File0 <- Files];
		_ ->
		    ok
	end.
	    
del_dir(Dir) ->
	case file:list_dir(Dir) of
		{ok, Files} ->
			[begin
				case file:delete(Dir ++ "/" ++ Filename) of
					ok -> ok;
					{error, eperm} ->
						case file:del_dir(Dir ++ "/" ++ Filename) of
							ok -> ok;
							{error, eexist} ->
								del_dir(Dir ++ "/" ++ Filename)
						end
				end
			end || Filename <- Files],
			file:del_dir(Dir);
		_ ->
			ok
	end.
	
rn_dir(OldName, NewName) ->
    case file:rename(OldName, NewName) of
        ok -> ok;
        {error, Reason} ->
            exit(lists:flatten(io_lib:format("failed to rename ~s to ~s: ~p", [OldName, NewName, Reason])))
    end.
	
do_cmd(Cmd, fail) ->
	case do_cmd(Cmd) of
		{0, ""} ->
			ok;
		{0, Output} ->
			print_cmd_output("~s~n", [Output]);
		{_, Output} ->
			exit(Output)
	end.
	
do_cmd(Cmd) ->
    Results = string:tokens(os:cmd(Cmd ++ "; echo $?"), "\n"),
    [ExitCode|Other] = lists:reverse(Results),
    {list_to_integer(ExitCode), string:join(lists:reverse(Other), "\n")}.
    
print_cmd_output(Format, Args) ->
	case get(verbose) of
		undefined -> print_cmd_output(Format, Args, false);
		Verbose -> print_cmd_output(Format, Args, Verbose)
	end.
	
print_cmd_output(_, _, false) -> ok; %% do not print verbose output
print_cmd_output(Format, Args, true) ->
	Str = lists:flatten(io_lib:format("    " ++ Format, Args)),
	Output = re:replace(Str, "\n", "\n    ", [global, {return, list}]),
	io:format(string:substr(Output, 1, length(Output)-4), []).

set_cwd_build_home(GlobalConfig) ->	
	set_cwd(proplists:get_value(build_dir, GlobalConfig, ".")).
	
set_cwd(Dir) ->
	case file:set_cwd(Dir) of
		ok -> 
			ok;
		{error, _} ->
			exit(lists:flatten(io_lib:format("failed to change working directory: ~s", [Dir])))
	end.